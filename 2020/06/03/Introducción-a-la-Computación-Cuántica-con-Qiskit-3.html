<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Introducción A La Computación Cuántica Con Qiskit 3 | Ruben Martínez Sánchez</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Introducción A La Computación Cuántica Con Qiskit 3" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="En el primer artículo de la serie vimos cómo aproximarnos a las distribuciones de probabilidad en la Computación Clásica que emplea bits como unidad básica de información y en el segundo comenzamos a asomarnos de forma superficial a la Computación Cuántica introduciendo conceptos como qubit, base canónica, superposición, regla de Born y finalizamos viendo cómo implementar un circuito cuántico con Qiskit que modelizaba el problema del lanzamiento de una moneda completamente sesgada que siempre devuelve ‘cara’ (que se corresponde con el valor de salida ‘0’)." />
<meta property="og:description" content="En el primer artículo de la serie vimos cómo aproximarnos a las distribuciones de probabilidad en la Computación Clásica que emplea bits como unidad básica de información y en el segundo comenzamos a asomarnos de forma superficial a la Computación Cuántica introduciendo conceptos como qubit, base canónica, superposición, regla de Born y finalizamos viendo cómo implementar un circuito cuántico con Qiskit que modelizaba el problema del lanzamiento de una moneda completamente sesgada que siempre devuelve ‘cara’ (que se corresponde con el valor de salida ‘0’)." />
<link rel="canonical" href="https://eldarsilver.github.io/ruben.martinez/2020/06/03/Introducci%C3%B3n-a-la-Computaci%C3%B3n-Cu%C3%A1ntica-con-Qiskit-3.html" />
<meta property="og:url" content="https://eldarsilver.github.io/ruben.martinez/2020/06/03/Introducci%C3%B3n-a-la-Computaci%C3%B3n-Cu%C3%A1ntica-con-Qiskit-3.html" />
<meta property="og:site_name" content="Ruben Martínez Sánchez" />
<meta property="og:image" content="https://eldarsilver.github.io/ruben.martinez/images/qiskit.jpeg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-06-03T00:00:00-05:00" />
<script type="application/ld+json">
{"description":"En el primer artículo de la serie vimos cómo aproximarnos a las distribuciones de probabilidad en la Computación Clásica que emplea bits como unidad básica de información y en el segundo comenzamos a asomarnos de forma superficial a la Computación Cuántica introduciendo conceptos como qubit, base canónica, superposición, regla de Born y finalizamos viendo cómo implementar un circuito cuántico con Qiskit que modelizaba el problema del lanzamiento de una moneda completamente sesgada que siempre devuelve ‘cara’ (que se corresponde con el valor de salida ‘0’).","@type":"BlogPosting","headline":"Introducción A La Computación Cuántica Con Qiskit 3","dateModified":"2020-06-03T00:00:00-05:00","datePublished":"2020-06-03T00:00:00-05:00","image":"https://eldarsilver.github.io/ruben.martinez/images/qiskit.jpeg","url":"https://eldarsilver.github.io/ruben.martinez/2020/06/03/Introducci%C3%B3n-a-la-Computaci%C3%B3n-Cu%C3%A1ntica-con-Qiskit-3.html","mainEntityOfPage":{"@type":"WebPage","@id":"https://eldarsilver.github.io/ruben.martinez/2020/06/03/Introducci%C3%B3n-a-la-Computaci%C3%B3n-Cu%C3%A1ntica-con-Qiskit-3.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/ruben.martinez/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://eldarsilver.github.io/ruben.martinez/feed.xml" title="Ruben Martínez Sánchez" /><link rel="shortcut icon" type="image/x-icon" href="/ruben.martinez/images/favicon.ico"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Introducción A La Computación Cuántica Con Qiskit 3 | Ruben Martínez Sánchez</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Introducción A La Computación Cuántica Con Qiskit 3" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="En el primer artículo de la serie vimos cómo aproximarnos a las distribuciones de probabilidad en la Computación Clásica que emplea bits como unidad básica de información y en el segundo comenzamos a asomarnos de forma superficial a la Computación Cuántica introduciendo conceptos como qubit, base canónica, superposición, regla de Born y finalizamos viendo cómo implementar un circuito cuántico con Qiskit que modelizaba el problema del lanzamiento de una moneda completamente sesgada que siempre devuelve ‘cara’ (que se corresponde con el valor de salida ‘0’)." />
<meta property="og:description" content="En el primer artículo de la serie vimos cómo aproximarnos a las distribuciones de probabilidad en la Computación Clásica que emplea bits como unidad básica de información y en el segundo comenzamos a asomarnos de forma superficial a la Computación Cuántica introduciendo conceptos como qubit, base canónica, superposición, regla de Born y finalizamos viendo cómo implementar un circuito cuántico con Qiskit que modelizaba el problema del lanzamiento de una moneda completamente sesgada que siempre devuelve ‘cara’ (que se corresponde con el valor de salida ‘0’)." />
<link rel="canonical" href="https://eldarsilver.github.io/ruben.martinez/2020/06/03/Introducci%C3%B3n-a-la-Computaci%C3%B3n-Cu%C3%A1ntica-con-Qiskit-3.html" />
<meta property="og:url" content="https://eldarsilver.github.io/ruben.martinez/2020/06/03/Introducci%C3%B3n-a-la-Computaci%C3%B3n-Cu%C3%A1ntica-con-Qiskit-3.html" />
<meta property="og:site_name" content="Ruben Martínez Sánchez" />
<meta property="og:image" content="https://eldarsilver.github.io/ruben.martinez/images/qiskit.jpeg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-06-03T00:00:00-05:00" />
<script type="application/ld+json">
{"description":"En el primer artículo de la serie vimos cómo aproximarnos a las distribuciones de probabilidad en la Computación Clásica que emplea bits como unidad básica de información y en el segundo comenzamos a asomarnos de forma superficial a la Computación Cuántica introduciendo conceptos como qubit, base canónica, superposición, regla de Born y finalizamos viendo cómo implementar un circuito cuántico con Qiskit que modelizaba el problema del lanzamiento de una moneda completamente sesgada que siempre devuelve ‘cara’ (que se corresponde con el valor de salida ‘0’).","@type":"BlogPosting","headline":"Introducción A La Computación Cuántica Con Qiskit 3","dateModified":"2020-06-03T00:00:00-05:00","datePublished":"2020-06-03T00:00:00-05:00","image":"https://eldarsilver.github.io/ruben.martinez/images/qiskit.jpeg","url":"https://eldarsilver.github.io/ruben.martinez/2020/06/03/Introducci%C3%B3n-a-la-Computaci%C3%B3n-Cu%C3%A1ntica-con-Qiskit-3.html","mainEntityOfPage":{"@type":"WebPage","@id":"https://eldarsilver.github.io/ruben.martinez/2020/06/03/Introducci%C3%B3n-a-la-Computaci%C3%B3n-Cu%C3%A1ntica-con-Qiskit-3.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

<link href="https://unpkg.com/@primer/css/dist/primer.css" rel="stylesheet" />
<link rel="stylesheet" href="//use.fontawesome.com/releases/v5.0.7/css/all.css"><link type="application/atom+xml" rel="alternate" href="https://eldarsilver.github.io/ruben.martinez/feed.xml" title="Ruben Martínez Sánchez" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"> </script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head><body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/ruben.martinez/">Ruben Martínez Sánchez</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/ruben.martinez/about/">About Me</a><a class="page-link" href="/ruben.martinez/_pages/conferences.html">Conference Videos</a><a class="page-link" href="/ruben.martinez/search/">Search</a><a class="page-link" href="/ruben.martinez/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Introducción A La Computación Cuántica Con Qiskit 3</h1><p class="post-meta post-meta-title"><time class="dt-published" datetime="2020-06-03T00:00:00-05:00" itemprop="datePublished">
        Jun 3, 2020
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      5 min read
    
</span></p>

    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>En el primer artículo de la serie vimos cómo aproximarnos a las distribuciones de probabilidad en la Computación Clásica que emplea bits como unidad básica de información y en el segundo comenzamos a asomarnos de forma superficial a la Computación Cuántica introduciendo conceptos como qubit, base canónica, superposición, regla de Born y finalizamos viendo cómo implementar un circuito cuántico con Qiskit que modelizaba el problema del lanzamiento de una moneda completamente sesgada que siempre devuelve ‘cara’ (que se corresponde con el valor de salida ‘0’).</p>

<p>Utilizaremos ese código como punto de partida para los temas que vamos a tratar en esta ocasión:</p>

<p><img src="https://eldarsilver.github.io/ruben.martinez/assets/img/2020-06-03-Introducción-a-la-Computación-Cuántica-con-Qiskit-3/media/image1.png" alt="" /></p>

<p><img src="https://eldarsilver.github.io/ruben.martinez/assets/img/2020-06-03-Introducción-a-la-Computación-Cuántica-con-Qiskit-3/media/image7.png" alt="" /></p>

<p><img src="https://eldarsilver.github.io/ruben.martinez/assets/img/2020-06-03-Introducción-a-la-Computación-Cuántica-con-Qiskit-3/media/image4.png" alt="" /></p>

<h2 id="esfera-bloch">Esfera Bloch</h2>

<p>Al realizar en el backend ‘<strong>qasm_simulator</strong>’ las 50 ejecuciones y posteriores medidas del circuito anterior formado por un qubit inicializado en el ket 0 se obtiene siempre la salida ‘0’ (cara de la moneda).</p>

<p>Sería muy útil disponer de algún mecanismo de visualización para facilitar la comprensión de los pasos que vamos dando y aquí es donde entra en escena la <strong>Esfera Bloch</strong>. Se trata de una representación que permite proyectar un estado cuántico a una localización de la superficie de una esfera con unas características un tanto especiales.</p>

<p>Habíamos visto que un qubit tiene 2 amplitudes de probabilidad (una correspondiente a cada base canónica) y como son números complejos (parte real y parte imaginaria) se necesitaría un espacio de 4 dimensiones. Pero como los vectores están normalizados esto elimina un grado de libertad por lo que podríamos emplear una representación en <strong>3 dimensiones</strong>, que como estaréis imaginando, será la Esfera Bloch.</p>

<table>
  <tbody>
    <tr>
      <td>Antes comentábamos que esta esfera tiene una serie de peculiaridades. Su <strong>polo norte</strong> se corresponde con el estado del **ket</td>
      <td>0&gt;** y su <strong>polo sur</strong> con el del **ket</td>
      <td>1&gt;<strong>. Intuitivamente esto podría extrañar ya que en el eje Z se encuentran 2 vectores que son **ortogonales</strong>. La potencia de este tipo de representación es que cualquier punto de la esfera se corresponderá con un estado cuántico y también podemos afirmar que cualquier <strong>estado cuántico puro</strong>, es decir, un estado cuántico representado por un ket (vector columnar) se podrá visualizar como un punto de la esfera. También podremos encontrar <strong>estados cuánticos mixtos</strong> (no descritos por un ket) que estarán representados dentro de la esfera.</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Ya es turno de volver a tocar un poco de código y ver cómo se visualiza esa Esfera Bloch. Para ello, en primer lugar vamos a emplear el backend ‘<strong>statevector_simulartor</strong>’ mediante llamada a <strong>BasicAer.get_backend()</strong>. A continuación, crearemos un circuito llamado ‘<strong>circuit</strong>’ formado por un registro cuántico (‘<strong>qr</strong>’) y por uno clásico (‘<strong>cr</strong>’). El objetivo es que el qubit almacenado en ‘qr’ se encuentre en el estado ket</td>
      <td>0&gt; (situación que ocurre por defecto) y visualizarlo en la Esfera Bloch. Hay que decir que para modificar el estado de los qubits emplearemos puertas cuánticas (matrices que transformarán los vectores columnares de los qubits). En este caso no hay que realizar ninguna modificación al qubit pero aun así hay que añadir una operación llamada ‘iden’ al circuito que corresponde con la matriz identidad.</td>
    </tr>
  </tbody>
</table>

<p>Un punto a señalar es que por convenio en los <strong>registros cuánticos</strong> la posición menos significativa será la de más a la izquierda. Es decir, si se define un registro cuántico que contendrá 2 qubits:</p>

<p><strong>qr = QuantumRegister(2)</strong></p>

<table>
  <tbody>
    <tr>
      <td>El qubit menos significativo, es decir qr[0], será el que esté más a la izquierda y el más significativo es de más a la derecha en la siguiente representación **</td>
      <td>00&gt;**.</td>
    </tr>
  </tbody>
</table>

<p>En el caso de los <strong>registros clásicos</strong> (en los que guardaremos los resultados de las mediciones de circuitos cuánticos) la posición menos significativa será la de más a la derecha como ocurre a la hora de representar bits.</p>

<p>Volviendo a nuestro ejemplo, una vez añadida al circuito la operación ‘<strong>iden</strong>’ sobre el qubit se invocará al método ‘<strong>execute</strong>’ sobre el circuito indicando el backend almacenando el manejador de esa llamada en la variable ‘<strong>job</strong>’. Una vez hecho esto, se invocará al método ‘<strong>plot_bloch_multivector</strong>’ haciéndole llegar el resultado de ‘<strong>job.result().get_statevector(circuit)</strong>’.</p>

<table>
  <tbody>
    <tr>
      <td>En la siguiente imagen puede verse el código completo y la visualización de la Esfera Bloch en la que aparece resaltada la flecha correspondiente al qubit en el estado del ket</td>
      <td>0&gt;.</td>
    </tr>
  </tbody>
</table>

<p><img src="https://eldarsilver.github.io/ruben.martinez/assets/img/2020-06-03-Introducción-a-la-Computación-Cuántica-con-Qiskit-3/media/image5.png" alt="" /></p>

<h2 id="superposición">Superposición</h2>

<table>
  <tbody>
    <tr>
      <td>Para entender el fenómeno de la Superposición vamos a seguir con el ejemplo del lanzamiento de una moneda pero ahora el objetivo es que no esté sesgada. Es decir, vamos a pasar del caso en que la moneda estaba completamente sesgada de forma que siempre se obtenía cara (ket</td>
      <td>0&gt;) a la situación de que en el 50% de los casos se obtenga cara y en el otro 50% se obtenga cruz que se corresponderá con el estado de superposición (\frac{1\ }{})((</td>
      <td>0 &gt; +</td>
      <td>1 &gt; ))donde</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>({(\frac{1}{})}^{2})= (\frac{1}{2}) de los casos que según la regla de Born la salida se corresponderá con el ket</td>
      <td>0&gt; y el resto al ket</td>
      <td>1&gt;.</td>
    </tr>
  </tbody>
</table>

<p>Una forma de realizar esta transformación será empleando la <strong>Quantum Gate ‘ry’</strong> que se corresponderá con una rotación de (\frac{\pi}{2})en el eje Y. Esa puerta se implementa mediante la matriz:</p>

<p><img src="https://eldarsilver.github.io/ruben.martinez/assets/img/2020-06-03-Introducción-a-la-Computación-Cuántica-con-Qiskit-3/media/image3.png" alt="" /></p>

<p>En futuros artículos de esta serie veremos más tipos de puertas cuánticas y entre ellas la puerta Hadamard que nos permitirá llegar también a un estado de Superposición.</p>

<table>
  <tbody>
    <tr>
      <td>A continuación, veremos el código para construir el circuito que parte de un qubit en el estado ket</td>
      <td>0&gt; , le aplica la puerta ‘ry’ para obtener una moneda no sesgada e invoca al método ‘<strong>plot_histogram</strong>’ sobre el resultado de 50 ejecuciones del circuito en el backend ‘<strong>qasm_simulator</strong>’ (almacenado en la variable ‘bk’) para poder obtener el conteo de veces en el que el lanzamiento de la moneda acaba en cada estado.</td>
    </tr>
  </tbody>
</table>

<p><img src="https://eldarsilver.github.io/ruben.martinez/assets/img/2020-06-03-Introducción-a-la-Computación-Cuántica-con-Qiskit-3/media/image6.png" alt="" /></p>

<p>Si queremos visualizar ese experimento en la Esfera Bloch el código sería el siguiente</p>

<p><img src="https://eldarsilver.github.io/ruben.martinez/assets/img/2020-06-03-Introducción-a-la-Computación-Cuántica-con-Qiskit-3/media/image2.png" alt="" /></p>

<p>Como se puede comprobar se ha producido una rotación de 90º sobre el eje Y.</p>

<p>En el siguiente artículo seguiremos jugando con puertas cuánticas. ¡No os lo perdáis!</p>

  </div><a class="u-url" href="/ruben.martinez/2020/06/03/Introducci%C3%B3n-a-la-Computaci%C3%B3n-Cu%C3%A1ntica-con-Qiskit-3.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/ruben.martinez/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/ruben.martinez/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/ruben.martinez/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>Causal Inference / AI / Robotics / Neuroscience / Quantum Adventures! Let&#39;s share!</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/eldarsilver" title="eldarsilver"><svg class="svg-icon grey"><use xlink:href="/ruben.martinez/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://twitter.com/eldarsilver" title="eldarsilver"><svg class="svg-icon grey"><use xlink:href="/ruben.martinez/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
