{
  
    
        "post0": {
            "title": "Introducción A La Computación Cuántica Con Qiskit 6",
            "content": "En el quinto artículo de esta serie hicimos un repaso general de los conceptos más importantes desarrollados hasta ese momento, poniendo especial foco en cómo codificar 1 qubit. Eso nos llevó a plantearnos cómo se conseguiría llevar a cabo la representación de estados cuánticos compuestos por varios qubits, lo que a su vez abrió el camino para el tema en el que vamos a centrarnos en esta publicación: el fenómeno conocido como entanglement. Vamos a incorporar un concepto más a nuestra mochila. ¡Pero tranquilos que no será nada pesada! . Entanglement . Vamos a comenzar de la misma forma que lo hicimos en el artículo anterior, recapitulando los puntos claves que se trataron en él. El primer tema que pudimos comprobar fue que la forma de construir estados cuánticos formados por varios qubits era mediante la operación del producto de tensores o producto Kronecker de los qubits individuales. Suponiendo que tenemos 2 qubits llamados ( | psi &gt;) y ( | psi’ &gt;): | . . El resultado de realizar el producto de tensores o producto Kronecker de esos 2 qubits será: . . Si estamos trabajando con estados cuánticos compuestos por 2 qubits entonces tendremos los siguientes vectores de base canónica: | 00&gt;, | 01&gt;, | 10&gt; y | 11&gt; en un espacio de números complejos de 4 dimensiones | . También introdujimos en el artículo anterior la idea de que cuando construimos espacios de alta dimensionalidad empleando la operación del producto de tensores de los qubits individuales no todos los vectores de ese espacio resultante pueden ser obtenidos mediante el producto Kronecker de sus componentes. . La mejor forma de entender algo es mediante ejemplos y por ello vamos a intentar demostrar ese concepto partiendo del siguiente estado de superposición de los kets | 00&gt; y | 11&gt;: | . . Como el vector resultante es una combinación lineal de 2 de los vectores canónicos ( | 00&gt; y | 11&gt;) del espacio de los números complejos de 4 dimensiones, podemos decir que este vector pertenece a dicho espacio de El problema es que esto no puede ser escrito como el producto Kronecker ( | psi &gt; otimes | psi’ &gt;) para cualesquiera . | . Para demostrarlo, vamos a escribir el estado cuántico como un producto Kronecker de sus componentes y posteriormente vamos a expandir el resultado sobre los vectores de base canónica de los complejos de 4 dimensiones: . . Podemos ver que no aparecen los kets | 01&gt; ni | 10&gt; en esta parte de la expresión: | . . Por lo que llegamos a la conclusión de que (a_{0}b_{1} = 0) y (a_{1}b_{0} = 0). El problema es que eso lleva a una contradicción ya que como (a_{1}b_{1} = 1)de ahí extraemos que (a_{1})no puede ser 0 por lo que deducimos que (b_{0})debe ser 0. Pero eso tampoco puede ser posible debido a que como (a_{0}b_{0} = 1)entonces (b_{0})no podría ser 0. . Esto nos lleva a que los estados que no pueden ser escritos como un producto de tensores reciben el nombre de entangled states o estados entrelazados. Se trata de un fenómeno físico que indica fuertes correlaciones entre variables aleatorias, por ejemplo, 2 qubits aunque dichos qubits estén separados por grandes distancias, de forma que estas correlaciones no son explicadas mediante la mecánica clásica. Esta propiedad nos permite entre otras cosas poder medir uno de los qubits entrelazados e instantáneamente poder determinar el valor del otro aunque ese otro qubit se encuentre en un estado probabilístico. . A continuación, vamos a ver cómo crear el estado empleando Qiskit: . . En este ejemplo, disponemos de 2 registros cuánticos qr[0] y qr[1] cada uno de ellos inicializado por defecto en el ket | 0&gt; y de 2 registros clásicos cr[0] y cr[1]. Creamos un circuito cuántico que dispone de esos 2 registros cuánticos qr y de los 2 registros clásicos cr. Una vez realizadas esas definiciones, aplicaremos la puerta Hadamard sobre el qubit 0 (el de más a la izquierda) siendo su definición: | . . Su definicón gráfica y su matriz son las siguientes: . . El estado parcial después de aplicar esa puerta Hadamard sobre el qubit 0 será . ( frac{1}{})( | 00&gt; + | 10&gt;). | . A continuación se aplicará sobre el resultado del paso anterior la puerta cx o también conocida como CNOT o controlled NOT. Esta puerta emplea 2 qubits, uno de control y otro denominado target, de forma que si el qubit de control es 1 entonces aplicará la puerta NOT o también conocida como x sobre el otro qubit (target). El efecto que provoca es el siguiente en caso de que el qubit de control sea el de más a la izquierda: . . Y aquí podemos ver su definición en forma de matriz y gráfica: . . Por lo que el resultado después de aplicar la puerta cx será ( frac{1}{})( | 00&gt; + | 11&gt;) estando los estados | 00&gt; y | 11&gt; en superposición. Esto puede comprobarse en el histograma donde cada uno de los estados aparece aproximadamente la mitad de las 100 veces (parámetro shots) que se repite la ejecución del circuito cuántico. | . Siguiendo este procedimiento vamos ver cómo se implementaría el estado: . . . Hasta aquí este artículo en el que además de trabajar con estados formados por varios qubits y de introducir el concepto de entanglement hemos empezado a modificar estados empleando algunas puertas cuánticas. En los siguientes artículos profundizaremos en las distintas puertas cuánticas disponibles y cómo emplearlas usando el framework Qiskit. ¡No os lo perdáis! .",
            "url": "https://eldarsilver.github.io/ruben.martinez/2020/06/05/Introducci%C3%B3n-a-la-Computaci%C3%B3n-Cu%C3%A1ntica-con-Qiskit-6.html",
            "relUrl": "/2020/06/05/Introducci%C3%B3n-a-la-Computaci%C3%B3n-Cu%C3%A1ntica-con-Qiskit-6.html",
            "date": " • Jun 5, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Introducción A La Computación Cuántica Con Qiskit 5",
            "content": "En el cuarto artículo de esta serie se introdujeron conceptos como superposición e interferencia y cómo codificarlos empleando Qiskit. Ahora es turno de ver cómo representar varios qubits y de adentrarnos en la propiedad conocida como entanglement. . Múltiples qubits . En este punto vamos a empezar a trabajar con estados cuánticos formados por varios qubits. Si recordamos lo que vimos anteriormente, un estado cuántico lo podemos asemejar a una distribución de probabilidad y un qubit es un estado cuántico de 2 niveles [a0, a1], de forma que podemos representar un estado cuántico mediante un vector columnar. . Para hacer referencia a su label (el nombre de dicho estado) se utilizará lo que se denomina ket en la notación Dirac, es decir, podemos referirnos a nuestro estado cuántico mediante el ket ( | psi &gt;). Para continuar refrescando conceptos previos, estas distribuciones de probabilidad deberán tener norma 1 en la norma L2. | . Por tanto recapitulando, podemos escribir un qubit de la siguiente forma: . . Donde a0 y a1 reciben el nombre de amplitudes de probabilidad y son números complejos, por lo que no sólo estaremos restringidos al cuadrante positivo del plano como ocurría con las distribuciones de probabilidad clásica cuya norma debe ser igual a 1 en la norma L1 y además cada probabilidad debía ser mayor o igual a 0 (lo que únicamente permitía representaciones en el cuadrante positivo citado anteriormente). . Como en computación cuántica el requisito de normalización debe ser la norma L2 eso puede formalizarse para el caso de un qubit en que: . . Podemos encontrar 2 qubits especiales llamados vectores de base canónica en 2 dimensiones que son: . . La parte interesante es que podemos expandir cualquier qubit en esta base de la siguiente forma dando lugar al fenómeno de superposición: . . Según la regla de Born, si extraemos una muestra del qubit ( | psi &gt;)obtendremos la salida 0 con una probabilidad ({ | a_{0} | }^{2}) y la salida 1 con una probabilidad de ({ | a_{1} | }^{2}). | . Una vez finalizado este repaso, toca ponernos manos a la obra con nuevos conceptos. Vamos a comprobar cómo añadir más qubits nos permite introducir otro fenómeno cuántico. . En este punto nos puede surgir la duda sobre cómo representar en forma de vector columnar 2 qubits. La forma de hacerlo es empleando la operación de producto de tensores o producto Kronecker. Para entenderlo vamos a ver un ejemplo en el que partimos de 2 qubits ( | psi &gt;)y ( | psi’ &gt;): | . . El producto de tensores o producto Kronecker de esos 2 qubits será: . . Vamos a concretar un poco más. Supongamos que tenemos almacenado en el registro cuántico qr0 un qubit que está en el estado | 0&gt; y también disponemos de otro registro cuántico llamado qr1 que de forma similar al anterior almacena un qubit en el estado | 0&gt;. Una forma de visualizar la regla del producto Kronecker de esos 2 qubits ( | 0&gt; ( otimes) | 0&gt;) sería mediante el siguiente código: | . . El estado resultante del producto Kronecker de esos dos qubits que cada uno de ellos se encuentra en el estado | 0&gt; se suele representar como | 00&gt;. Si quisiéramos representar los estados | 01&gt;, | 10&gt; y | 11&gt; tendríamos que seguir el mismo procedimiento que hemos realizado para generar el ket | 00&gt;. | . Hay que señalar que los estados | 00&gt;, | 01&gt;, | 10&gt; y | 11&gt; forman los vectores de base canónica en un espacio de números complejos de 4 dimensiones denotado como | . Cuando empleamos modelos de Machine Learning y Deep Learning también trabajamos con espacios de alta dimensionalidad pero no se construyen como un producto de tensores sino que suele tratarse de (R^{n}), es decir, un mapeo a los números reales para alguna dimensión ‘n’. . El efecto de construir espacios de alta dimensionalidad empleando producto de tensores es que no todos los vectores de dicho espacio pueden ser escritos como el producto de vectores de los elementos de ese espacio. Este hecho que en principio puede parecer confuso, nos permitirá descubrir la propiedad cuántica conocida como entanglement, que recorreremos en el siguiente artículo viendo cómo la podemos observar empleando Qiskit. ¡No te lo pierdas! .",
            "url": "https://eldarsilver.github.io/ruben.martinez/2020/06/05/Introducci%C3%B3n-a-la-Computaci%C3%B3n-Cu%C3%A1ntica-con-Qiskit-5.html",
            "relUrl": "/2020/06/05/Introducci%C3%B3n-a-la-Computaci%C3%B3n-Cu%C3%A1ntica-con-Qiskit-5.html",
            "date": " • Jun 5, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Introducción A La Computación Cuántica Con Qiskit 4",
            "content": "En el segundo artículo de esta serie se comentaba que las amplitudes de probabilidad son números complejos en contraposición con los números reales positivos que se emplean en Computación Clásica. . Superposición y números complejos . Los números complejos tiene la forma de a + bi donde ‘a’ es la parte real y ‘bi’ es la parte imaginaria siendo ‘a’ y ‘b’ números reales positivos o negativos e ‘i’ se corresponde con el número imaginario de forma que i = () (ya que no tenemos números reales que después de elevarlos al cuadrado sigan siendo negativos, por lo que no podremos volver hacia atrás haciendo la raíz cuadrada). . Los números complejos permiten representar coordenadas en un plano de manera que la parte real se asociará al eje X y la parte imaginaria con el eje Y. Por lo que sumar en la parte real supondrá movernos hacia la derecha, restar en la parte real movernos hacia la izquierda, sumar en la parte imaginaria nos permitirá desplazarnos hacia arriba y restar en la parte imaginaria supondrá movernos hacia abajo en el plano. . Suma / Resta de Números Complejos . (7 + 3i) + (3 - 5i) = (10 -2i) . Multiplicación de Números Complejos . (7 + 3i) * (3 -5i) = 7 * 3 + 7 * (-5i) + 3i * 3 + 3i * (-5i) = 21 + (-35i) + 9i + (-15(i^{2})) = 21 -26i -15*(-1) = 36 - 26i . La razón por la que (i^{2})simplifica a (-1) es porque i = () . . División de Números Complejos . Para realizar la división de números complejos hay que introducir el concepto de conjugada de números complejos, que consiste en cambiar el signo a la parte imaginaria. Por ejemplo la conjugada del número complejo (a + bi) será (a - bi). Multiplicar un número complejo por su conjugada supone que los términos centrales se cancelan: . (a + bi) * (a - bi) = (a^{2} - abi + abi - {(bi)}^{2}) . Para realizar la división de números complejos multiplicaremos al numerador y al denominador por la conjugada del denominador: . (7 + 3i) / (3 - 5i) = ((7 + 3i) * (3 + 5i)) / ((3 - 5i) * (3 + 5i)) . Para comprobar la utilidad de emplear números complejos vamos a realizar un circuito cuántico que aplique una rotación ‘ry’ de 90º pero ahora al ket | 1&gt;. | . Hemos visto que todo qubit comienza inicializado en el estado ket | 0&gt; por lo que tendremos que aplicar la puerta cuántica ‘x’ (que se correspondería con una puerta lógica NOT) sobre el qubit para que pase a estar en estado | 1&gt;. | . La puerta cuántica ‘x’ se corresponderá con la matriz: . . Una vez que el qubit se encuentre en el | 1&gt; aplicaremos la puerta ‘ry’ con un ángulo de 90º para realizar dicha rotación: | . . En el tercer artículo de esta serie se aplicó la puerta ‘x’ sobre el qubit en el estado | 0&gt; y el resultado fue: | . . Se puede comprobar que cuando se aplica la rotación ‘ry’ sobre el ket | 1&gt; el resultado es similar al anterior pero con signo opuesto, por lo que tendremos una amplitud de probabilidad negativa. El estado obtenido será: | . . La utilidad de disponer de números complejos para representar las amplitudes de probabilidad de los estados cuánticos se hace patente cuando se comprueba que el signo negativo del ket | 0&gt; anterior no puede observarse al realizar la medición de las estadísticas de la ejecución del circuito cuántico. Para obtener dichas estadísticas de las frecuencias de cada resultado se ha empleado el backend ‘qasm_simulator’: | . . Se puede comprobar que prácticamente se han producido el mismo número de caras (‘0s’) que de cruces (‘1s’). La utilización de números complejos permite modelar un fenómeno de mecánica cuántica conocido como ‘interferencia’ según el cual las amplitudes de probabilidad puede interactuar unas veces constructiva y otras destructivamente. Una forma de comprobarlo es aplicar sobre un qubit en el estado | 0&gt; dos rotaciones ‘ry’ consecutivas de 90º. Al realizarlo obtendremos el ket | 1&gt; aunque durante el proceso hubo cierta superposición. | . El código para realizar este experimento en el que se realizarán 50 ejecuciones del circuito cuántico sobre el backend ‘qasm_simulator’ y se obtendrá el histograma de los resultados es el siguiente: . () . En próximos artículos seguiremos avanzando tratando más propiedades presentes en mecánica cuántica como por ejemplo el ‘Entanglement’ y viendo cómo implementarlas empleando el framework Qiskit. ¡Os esperamos! .",
            "url": "https://eldarsilver.github.io/ruben.martinez/2020/06/04/Introducci%C3%B3n-a-la-Computaci%C3%B3n-Cu%C3%A1ntica-con-Qiskit-4.html",
            "relUrl": "/2020/06/04/Introducci%C3%B3n-a-la-Computaci%C3%B3n-Cu%C3%A1ntica-con-Qiskit-4.html",
            "date": " • Jun 4, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Introducción A La Computación Cuántica Con Qiskit 3",
            "content": "En el primer artículo de la serie vimos cómo aproximarnos a las distribuciones de probabilidad en la Computación Clásica que emplea bits como unidad básica de información y en el segundo comenzamos a asomarnos de forma superficial a la Computación Cuántica introduciendo conceptos como qubit, base canónica, superposición, regla de Born y finalizamos viendo cómo implementar un circuito cuántico con Qiskit que modelizaba el problema del lanzamiento de una moneda completamente sesgada que siempre devuelve ‘cara’ (que se corresponde con el valor de salida ‘0’). . Utilizaremos ese código como punto de partida para los temas que vamos a tratar en esta ocasión: . . . . Esfera Bloch . Al realizar en el backend ‘qasm_simulator’ las 50 ejecuciones y posteriores medidas del circuito anterior formado por un qubit inicializado en el ket 0 se obtiene siempre la salida ‘0’ (cara de la moneda). . Sería muy útil disponer de algún mecanismo de visualización para facilitar la comprensión de los pasos que vamos dando y aquí es donde entra en escena la Esfera Bloch. Se trata de una representación que permite proyectar un estado cuántico a una localización de la superficie de una esfera con unas características un tanto especiales. . Habíamos visto que un qubit tiene 2 amplitudes de probabilidad (una correspondiente a cada base canónica) y como son números complejos (parte real y parte imaginaria) se necesitaría un espacio de 4 dimensiones. Pero como los vectores están normalizados esto elimina un grado de libertad por lo que podríamos emplear una representación en 3 dimensiones, que como estaréis imaginando, será la Esfera Bloch. . Antes comentábamos que esta esfera tiene una serie de peculiaridades. Su polo norte se corresponde con el estado del **ket | 0&gt;** y su polo sur con el del **ket | 1&gt;. Intuitivamente esto podría extrañar ya que en el eje Z se encuentran 2 vectores que son **ortogonales. La potencia de este tipo de representación es que cualquier punto de la esfera se corresponderá con un estado cuántico y también podemos afirmar que cualquier estado cuántico puro, es decir, un estado cuántico representado por un ket (vector columnar) se podrá visualizar como un punto de la esfera. También podremos encontrar estados cuánticos mixtos (no descritos por un ket) que estarán representados dentro de la esfera. | . Ya es turno de volver a tocar un poco de código y ver cómo se visualiza esa Esfera Bloch. Para ello, en primer lugar vamos a emplear el backend ‘statevector_simulartor’ mediante llamada a BasicAer.get_backend(). A continuación, crearemos un circuito llamado ‘circuit’ formado por un registro cuántico (‘qr’) y por uno clásico (‘cr’). El objetivo es que el qubit almacenado en ‘qr’ se encuentre en el estado ket | 0&gt; (situación que ocurre por defecto) y visualizarlo en la Esfera Bloch. Hay que decir que para modificar el estado de los qubits emplearemos puertas cuánticas (matrices que transformarán los vectores columnares de los qubits). En este caso no hay que realizar ninguna modificación al qubit pero aun así hay que añadir una operación llamada ‘iden’ al circuito que corresponde con la matriz identidad. | . Un punto a señalar es que por convenio en los registros cuánticos la posición menos significativa será la de más a la izquierda. Es decir, si se define un registro cuántico que contendrá 2 qubits: . qr = QuantumRegister(2) . El qubit menos significativo, es decir qr[0], será el que esté más a la izquierda y el más significativo es de más a la derecha en la siguiente representación ** | 00&gt;**. | . En el caso de los registros clásicos (en los que guardaremos los resultados de las mediciones de circuitos cuánticos) la posición menos significativa será la de más a la derecha como ocurre a la hora de representar bits. . Volviendo a nuestro ejemplo, una vez añadida al circuito la operación ‘iden’ sobre el qubit se invocará al método ‘execute’ sobre el circuito indicando el backend almacenando el manejador de esa llamada en la variable ‘job’. Una vez hecho esto, se invocará al método ‘plot_bloch_multivector’ haciéndole llegar el resultado de ‘job.result().get_statevector(circuit)’. . En la siguiente imagen puede verse el código completo y la visualización de la Esfera Bloch en la que aparece resaltada la flecha correspondiente al qubit en el estado del ket | 0&gt;. | . . Superposición . Para entender el fenómeno de la Superposición vamos a seguir con el ejemplo del lanzamiento de una moneda pero ahora el objetivo es que no esté sesgada. Es decir, vamos a pasar del caso en que la moneda estaba completamente sesgada de forma que siempre se obtenía cara (ket | 0&gt;) a la situación de que en el 50% de los casos se obtenga cara y en el otro 50% se obtenga cruz que se corresponderá con el estado de superposición ( frac{1 }{})(( | 0 &gt; + | 1 &gt; ))donde | . ({( frac{1}{})}^{2})= ( frac{1}{2}) de los casos que según la regla de Born la salida se corresponderá con el ket | 0&gt; y el resto al ket | 1&gt;. | . Una forma de realizar esta transformación será empleando la Quantum Gate ‘ry’ que se corresponderá con una rotación de ( frac{ pi}{2})en el eje Y. Esa puerta se implementa mediante la matriz: . . En futuros artículos de esta serie veremos más tipos de puertas cuánticas y entre ellas la puerta Hadamard que nos permitirá llegar también a un estado de Superposición. . A continuación, veremos el código para construir el circuito que parte de un qubit en el estado ket | 0&gt; , le aplica la puerta ‘ry’ para obtener una moneda no sesgada e invoca al método ‘plot_histogram’ sobre el resultado de 50 ejecuciones del circuito en el backend ‘qasm_simulator’ (almacenado en la variable ‘bk’) para poder obtener el conteo de veces en el que el lanzamiento de la moneda acaba en cada estado. | . . Si queremos visualizar ese experimento en la Esfera Bloch el código sería el siguiente . . Como se puede comprobar se ha producido una rotación de 90º sobre el eje Y. . En el siguiente artículo seguiremos jugando con puertas cuánticas. ¡No os lo perdáis! .",
            "url": "https://eldarsilver.github.io/ruben.martinez/2020/06/03/Introducci%C3%B3n-a-la-Computaci%C3%B3n-Cu%C3%A1ntica-con-Qiskit-3.html",
            "relUrl": "/2020/06/03/Introducci%C3%B3n-a-la-Computaci%C3%B3n-Cu%C3%A1ntica-con-Qiskit-3.html",
            "date": " • Jun 3, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Introducción A La Computación Cuántica Con Qiskit 1",
            "content": "Aquí comienza una serie de artículos en los que se pretende hacer un recorrido por los principios básicos de la Computación Cuántica. Y como la mejor forma de aprender es hacerlo de forma práctica, vamos a acercarnos a este paradigma empleando Qiskit, el framework que ofrece IBM para desarrollar algoritmos que se aprovechen de las particularidades que ofrece la física cuántica aplicada a la computación. . Comencemos por la pregunta más obvia. ¿Cuál es la principal diferencia entre la Computación Clásica y la Computación Cuántica? . Para abordar esa pregunta vamos a comenzar viendo cómo se almacena la información y cómo se tratan las distribuciones de probabilidad en Computación Clásica para en un siguiente artículo confrontarlo con la forma de trabajar en Computación Cuántica. . Distribuciones de Probabilidad en Computación Clásica . Un primer aspecto diferenciador es cómo se representa la unidad mínima de información. En Computación Clásica, la que se emplea para la arquitectura y el software presente en los servidores, ordenadores de sobremesa, portátiles, dispositivos móviles, el procesamiento de información se realiza manipulando bits, de forma que un bit es un fragmento de información que puede tomar o bien el valor 1 o el valor 0, pero sólo uno de esos dos valores. . Dentro de este enfoque, vamos a tratar el tema de distribuciones de probabilidad clásica poniendo el ejemplo del lanzamiento de una moneda que está sesgada. De manera que vamos a representar el resultado de dicho lanzamiento mediante una variable aleatoria X que tomará el valor “0” cuando salga “cara” y el valor “1” cuando se obtenga “cruz”. . Formalmente, por cada lanzamiento de moneda se puede decir que se obtendrá “cara” con una probabilidad P(X=0) = (p_{0}) y “cruz” con P(X=1) = (p_{1}) siendo (p_{i}) &gt;= 0 (es decir la probabilidad de obtener “cara” o de obtener “cruz” será siempre mayor o igual que 0) y (p_{i} = 1). . Vamos a extraer muestras de una distribución aleatoria binomial definida como: . donde ‘N’ es el número de éxitos, ‘n’ es el número de intentos y ‘p’ es la probabilidad de éxito en cada intento. . En el siguiente ejemplo el número de intentos será 1 y la probabilidad de éxito (prob_1) será 0.2: . . A continuación, podemos comprobar como la suma de las observaciones de 1’s y de 0’s suman 1: . . Si queremos representar visualmente (p_{o}) y (p_{1}) veremos que estarán restringidos al cuadrante positivo ya que deben ser mayores o iguales que 0 debido al requisito de normalización. En el siguiente gráfico podemos comprobar como todas las distribuciones de probabilidad del lanzamiento de monedas sesgadas y no segadas caen dentro de la siguiente línea recta del cuadrante positivo: . . Una forma de representar probabilidades es en forma de vector columnar , de forma que ponemos una flecha encima del nombre de la variable ‘p’ para diferenciarlo de un escalar. En este caso tenemos un vector representando a una distribución de probabilidad y cuando esto ocurre, recibe el nombre de vector estocástico. . El requisito de normalización indica que la norma del vector está restringida a 1 en la norma (l_{1})lo que se puede expresar como: . . Pero además, como (p_{ text{i }})&gt;= 0 estaremos restringidos al cuadrante positivo del círculo unitario. Esto se puede comprobar calculando la norma (l_{1})del vector ‘p’ donde prob_0 = 0.8 y prob_1 = 0.2. . . El primer elemento del vector ‘p’ se corresponderá con la probabilidad de obtener cara (prob_0) y el segundo con la probabilidad de obtener cruz (prob_1). Si quisiéramos extraer, por ejemplo, prob_0 podríamos proyectar el vector ‘p’ sobre el primer eje. Esa proyección se corresponde con la matriz de transformación M_0 = . Si calculamos la longitud de la norma (l_{1}) del resultado de aplicar la matriz M_0 al vector ‘p’ obtendremos la probabilidad prob_0. . . Para obtener la probabilidad de obtener cruz tendríamos que proyectar el vector ‘p’ sobre el segundo eje de la siguiente forma: . . Esto nos lleva a la cuestión de cómo transformar una distribución de probabilidad en otra, por ejemplo, para cambiar el sesgo de una moneda. . Hemos visto que una distribución de probabilidad se puede representar como un vector estocástico y para modificarlo podemos multiplicar una matriz de transformación sobre dicho vector siempre que esa matriz cumpla unos requisitos: . Como son que cada una de sus columnas debe sumar 1 (la suma de todas las probabilidades debe ser 1). . | Además debemos multiplicar esa matriz por la izquierda del vector. . | . Esta matriz recibe el nombre de left stochastic matrix. En el siguiente ejemplo veremos como transformar un vector estocástico ‘p’ correspondiente a una moneda no sesga (50% de probabilidad de obtener cara y 50% de obtener cruz) en otra que sí está sesgada después de multiplicar a ‘p’ por la izquierda por una left stochastic matrix: . . Para terminar este primer artículo, vamos a introducir el concepto de Entropía como medida de desorden o en nuestro caso, de falta de predictibilidad cuya definición formal será: . . En el siguiente gráfico comprobaremos cómo la Entropía será máxima en el caso de una moneda no sesgada, que se corresponde con una distribución uniforme: . . En siguientes artículos comenzaremos a movernos por el apasionante mundo de la Computación Cuántica haciendo paralelismos con los conceptos que acabamos de ver. ¡No te los pierdas! .",
            "url": "https://eldarsilver.github.io/ruben.martinez/2020/06/01/Introducci%C3%B3n-a-la-Computaci%C3%B3n-Cu%C3%A1ntica-con-Qiskit-1.html",
            "relUrl": "/2020/06/01/Introducci%C3%B3n-a-la-Computaci%C3%B3n-Cu%C3%A1ntica-con-Qiskit-1.html",
            "date": " • Jun 1, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master- badges: true- comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . #collapse-hide import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . #collapse-show cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # single-value selection over [Major_Genre, MPAA_Rating] pairs # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(movies).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(movies).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=alt.Y(&#39;IMDB_Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=600, height=400 ) . Example 3: More Tooltips . # select a point for which to provide details-on-demand label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=700, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; df = pd.read_json(movies) # display table with pandas df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://eldarsilver.github.io/ruben.martinez/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://eldarsilver.github.io/ruben.martinez/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This is where you put the contents of your About page. Like all your pages, it’s in Markdown format. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://eldarsilver.github.io/ruben.martinez/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://eldarsilver.github.io/ruben.martinez/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}